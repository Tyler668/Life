{"version":3,"sources":["utils/useAnimFrame.js","utils/drawBoard.js","components/Window.js","App.js","serviceWorker.js","index.js"],"names":["useAnimFrame","timestamp","doAnimCB","useState","prevTimeStamp","continueAnimation","useRef","setStarted","slowTime","generation","onFrame","useCallback","current","milliseconds","date","Date","now","currentDate","sleep","requestAnimationFrame","console","log","canvas","document","querySelector","getContext","context","width","height","columns","rows","render","grid","col","length","row","cell","beginPath","rect","fillStyle","getRandomColor","fill","color","i","Math","floor","random","Window","props","gen","setGen","useEffect","Array","map","handleCustomClick","e","target","getBoundingClientRect","x","clientX","left","y","clientY","top","clickX","clickY","customLayout","former","relativeCellX","relativeCellY","customRender","moment","elapsedTime","newGen","neighbors","j","xcell","ycell","nextGen","cancelAnimation","className","onClick","preventDefault","window","location","addEventListener","App","Boolean","hostname","match","ReactDOM","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.af1bb6e6.chunk.js","sourcesContent":["import React, { useEffect, useState, useCallback, useRef } from 'react'\r\n\r\n//Custom hook for using animation frame\r\n\r\nfunction sleep(milliseconds) { //Slow the roll\r\n    const date = Date.now();\r\n    let currentDate = null;\r\n    do {\r\n        currentDate = Date.now();\r\n    } while (currentDate - date < milliseconds);\r\n}\r\n\r\nexport const useAnimFrame = (timestamp, doAnimCB) => {\r\n    const [prevTimeStamp, setPrevTimeStamp] = useState(timestamp - 30);\r\n    const continueAnimation = useRef();\r\n    const [started, setStarted] = useState(false)\r\n    const slowTime = useRef(false)\r\n    const generation = useRef(0)\r\n\r\n\r\n    //Request the first frame to kick things off\r\n    const onFrame = useCallback((timestamp) => {\r\n        if(continueAnimation.current){\r\n            generation.current++\r\n            if(slowTime.current){\r\n                sleep(400)\r\n            }\r\n            // console.log('continueanimation',continueAnimation)\r\n            requestAnimationFrame(onFrame);\r\n            console.log('Generation:', generation.current)\r\n            const elapsed = prevTimeStamp - timestamp;\r\n            doAnimCB(elapsed);\r\n        }}, [continueAnimation])\r\n\r\n\r\n\r\n    //This will stop the hook from calling the next animation frame\r\n    const cancelAnimation = () => {\r\n        continueAnimation.current = false;\r\n    };\r\n\r\n    return [cancelAnimation, setStarted, onFrame, continueAnimation, slowTime, generation];\r\n};","//Initialize the canvas via DOM selector\r\n//Set variables for resolution and grid size\r\n\r\nvar canvas = document.querySelector('canvas');\r\nif (canvas.getContext) {\r\n  var context = canvas.getContext('2d');\r\n}\r\n\r\nvar resolution = 10\r\n\r\ncanvas.width = 1000;\r\ncanvas.height = 1000;\r\n\r\nconst columns = canvas.width / resolution;\r\nconst rows = canvas.height / resolution;\r\n\r\n// Calculate next generation of board based on rules of the game\r\nexport function nextGen(grid) {\r\n  // generation++\r\n  const newGen = grid.map(former => [...former]);\r\n\r\n  for (let col = 0; col < grid.length; col++) {\r\n    for (let row = 0; row < grid[col].length; row++) {\r\n      const cell = grid[col][row];\r\n      let neighbors = 0;\r\n      for (let i = -1; i < 2; i++) {\r\n        for (let j = -1; j < 2; j++) {\r\n          if (i === 0 && j === 0) {\r\n            continue;\r\n          }\r\n          const xcell = col + i;\r\n          const ycell = row + j;\r\n\r\n          if(xcell >= 0 && ycell >= 0 && xcell < columns && ycell < rows){\r\n            const neighbor = grid[col + i][row + j];\r\n            neighbors += neighbor;\r\n          }\r\n        }\r\n      }\r\n\r\n      //Rules of survival\r\n      if (cell === 1 && neighbors < 2) {\r\n        newGen[col][row] = 0\r\n      }\r\n      else if (cell === 1 && neighbors > 3) {\r\n        newGen[col][row] = 0\r\n      }\r\n      else if (cell === 0 && neighbors === 3) {\r\n        newGen[col][row] = 1\r\n      }\r\n\r\n    }\r\n  }\r\n  // console.log('NEW GEN', newGen)\r\n  return newGen\r\n}\r\n\r\n// Draw an initial starting board of random cells\r\nexport function drawBoard() {\r\n  let grid = new Array(columns).fill(null)\r\n    .map(() => new Array(rows).fill(null)\r\n      .map(() => Math.floor(Math.random() * 2)));\r\n\r\n  //Populating board\r\n  return grid\r\n}\r\n\r\n// Render the current board array to a canvas\r\nexport function render(grid) {\r\n\r\n  for (let col = 0; col < grid.length; col++) {\r\n    for (let row = 0; row < grid[col].length; row++) {\r\n      const cell = grid[col][row]\r\n\r\n      context.beginPath();\r\n      context.rect(col * resolution, row * resolution, resolution, resolution);\r\n      context.fillStyle = cell === 1 ? `${getRandomColor()}` : 'black';\r\n      // context.stroke();\r\n      context.fill();\r\n    }\r\n  }\r\n}\r\n\r\n// Prepare an empty grid for custom layouts\r\nexport function emptyGrid(){\r\n  let grid = new Array(columns).fill(null)\r\n  .map(() => new Array(rows).fill(0))\r\n\r\n  return grid\r\n}\r\n\r\n// Handle the clicking events and positional canvas rendering for custom squares\r\nexport function customRender(grid, clickX, clickY){\r\n  const customLayout = grid.map(former => [...former]);\r\n\r\n  let relativeCellX = Math.floor(clickX / resolution)\r\n  let relativeCellY = Math.floor(clickY / resolution)\r\n  \r\n  console.log('Cell ', relativeCellX,',', relativeCellY)\r\n  console.log('Relevant', customLayout[relativeCellX][relativeCellY])\r\n\r\n  customLayout[relativeCellX][relativeCellY] = 1\r\n\r\n    \r\n    console.log('Custom layout:', customLayout)\r\n    return(customLayout)\r\n}\r\n\r\n//Set squares to a random color for prettyfication\r\nfunction getRandomColor() {\r\n  var letters = '0123456789ABCDEF';\r\n  var color = '#';\r\n  for (var i = 0; i < 6; i++) {\r\n    color += letters[Math.floor(Math.random() * 16)];\r\n  }\r\n  return color;\r\n}\r\n","import React, { useRef, useState, useEffect } from 'react';\r\nimport { useAnimFrame } from '../utils/useAnimFrame.js'\r\nimport moment from 'moment'\r\nimport { drawBoard, render, nextGen, customRender, emptyGrid } from '../utils/drawBoard.js';\r\n\r\n\r\n\r\nexport const Window = (props) => {\r\n    let grid;\r\n    let [gen, setGen] = useState(0)\r\n\r\n    // Set up board on launch\r\n    useEffect(() => {\r\n        grid = drawBoard()\r\n        render(grid)\r\n    })\r\n\r\n\r\n    // Recursive cb function, calls next frame, increments generation\r\n    const doAnimation = (elapsedTime) => {\r\n        gen = gen+1\r\n        setGen(gen)\r\n        grid = nextGen(grid)\r\n        render(grid)  \r\n    };\r\n\r\n\r\n    // Handlers for the various button functionalities\r\n    function handleReload(e) {\r\n        e.preventDefault();\r\n        window.location = '/'\r\n    }\r\n\r\n    function handlePause(e) {\r\n        \r\n        e.preventDefault()\r\n        cancelAnimation()\r\n        \r\n    }\r\n\r\n    function handleStart(e) {\r\n        e.preventDefault()\r\n        requestAnimationFrame(onFrame)\r\n        continueAnimation.current = true\r\n    }\r\n\r\n    function handleSlow(e) {\r\n        e.preventDefault();\r\n        slowTime.current = !slowTime.current\r\n    }\r\n\r\n    let canvas = document.querySelector(\"canvas\")\r\n\r\n    function handleCustom(e) {\r\n        grid = emptyGrid()\r\n        render(grid)\r\n        canvas.addEventListener(\"click\", handleCustomClick);\r\n    }\r\n\r\n    // Send the position of the user's mouse relative to the canvas to the customRender function\r\n    function handleCustomClick(e) {\r\n        var rect = e.target.getBoundingClientRect();\r\n        var x = e.clientX - rect.left; //x position within the element.\r\n        var y = e.clientY - rect.top;  //y position within the element.\r\n\r\n        console.log('[', x, ',', y, ']')\r\n        grid = customRender(grid, x, y)\r\n        render(grid)\r\n    }\r\n\r\n\r\n\r\n    //Destructuring the things we need from the animation custom hook\r\n    const [cancelAnimation, setStarted, onFrame, continueAnimation, slowTime, generation] = useAnimFrame(moment.now(), doAnimation)\r\n\r\n\r\n    return (\r\n        <div>\r\n            <div>\r\n                <h2 className = 'title'>{`Generation: ${gen}`}</h2>\r\n            </div>\r\n            <div className='controls'>\r\n                <button onClick={handlePause}>Pause</button>\r\n                <button onClick={handleStart}>Start</button>\r\n                <button onClick={handleReload}>Random</button>\r\n                <button onClick={handleCustom}>Custom</button>\r\n                <button onClick={handleSlow}>Slo-Mo</button>\r\n            </div>\r\n        </div>\r\n    );\r\n}\r\n\r\n\r\nexport default Window;\r\n","import React, { useEffect, useRef } from 'react';\n// import logo from './logo.svg';\n// import './App.css';\n// import AnimFrame from './functions/onAnimFrame.js'\nimport { Window } from './components/Window.js'\nimport Info from './components/info.js'\nimport { drawBoard } from './utils/drawBoard.js'\n\n\n\nfunction App() {\n\n\n  // window.onload = function draw(){\n  //   drawBoard()\n  // }\n\n\n  return (\n    <div className=\"App\">\n      \n      <div className='display'>\n        {/* <Info className = 'info'/> */}\n        <Window />\n      </div>\n    </div>\n  );\n}\n\n\nexport default App;\n\n\n//Useful get pixel value function\n/*\n\n * Get a pixel value from imageData\n *\n * @param imageData HTML canvas imagedata from getImageData()\n * @param x X coordinate to get pixels from\n * @param y Y coordinate to get pixels from\n * @return Array [R,G,B,A] for the pixel in question, or null if out of bounds\n\nfunction getPixel(imageData, x, y) {\n  const w = imageData.width; // Conveniently the width is here\n  const h = imageData.height;\n\n  if (x < 0 || x >= w || y < 0 || y >= h) {\n      // Out of bounds\n      return null;\n  }\n\n  // Compute index within the array\n  const index = (w * y + x) * 4;\n\n  // Return a copy of the R, G, B, and A elements\n  return imageData.data.slice(index, index + 4);\n}\n\n// Example Usage\n\nconst canvas = document.querySelector('#my-canvas');\nconst ctx = canvas.getContext('2d');\nconst imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n\nconst pixelRGBA = getPixel(imageData, 10, 10);\n\nconsole.log(pixelRGBA);\n\n*/","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}